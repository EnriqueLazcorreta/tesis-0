% !TEX root = ../../../Lazcorreta.Tesis.tex
\ABIERTO

La lectura de un \catalogo comprimido es elemental si se ha optado por guardar $\aprioriL_{reducido}$ para la clase. Se dará prioridad al valor de la clase por lo que cada vez que se lea un registro se comprobará si el primer ítem se corresponde con un valor de la clase o si el valor de la clase se ha omitido, con lo que sabemos que la lectura se corresponde con el valor de la clase no utilizado en el \catalogo comprimido.

Cada registro aumentará el \soporte de un máximo de $M$ \itemsets, buscados secuencialmente a partir del valor de la clase. Cada vez que se lee un valor del registro (tras comprobar si el primero es o no información sobre la clase y actuar en consecuencia) se incrementa el \soporte del hijo con índice $itemLeido - itemAnterior - 1 numHermanosItemAnterior$. De este modo con una única lectura de \D se completa $\aprioriL_{reducido}$ del que se puede obtener fácilmente cualquier \soporte de \aprioriL.

Si se ha optado por el formato $\aprioriL_{compacto}$ se leen uno a uno los ítems del registro aumentando sólo un elemento de $\aprioriL_{compacto}$ tras cada lectura (al contrario que en \apriori que se busca en el resto de ramas en que esté guardado). Se lee el primer ítem y se incremente su \soporte en $\aprioriL[1][item1]$, se lee el segundo ítem y se incremente su \soporte en $\aprioriL[1][item1]-\aprioriL[2][item2]$\ldots Con lo que no sólo se lee una vez \D si no que se hace sólo una búsqueda por \transaccion utilizando índices directos en lugar de comparaciones recursivas\ldots

El tamaño de $\aprioriL_{compacto}$ depende del número de atributos, $M$, del número de valores asignado a cada atributo, $n_i, i=1\ldots M$ y de su ocurrencia en \D (en \mushroom el atributo TAL tiene TANTOS valores pero sólo aparece el valor TAL en el \catalogo, lo que reduce el número de ítems a considerar en el análisis).

Para simplificar la notación en vez de hablar de clase y atributos consideraremos a la clase como un atributo. Será el primer atributo para simplificar la tarea de \clasificacion aunque podría ser cualquier otro atributo.

Sea $item_i \in \{1\ldots N\}$ un conjunto ordenado de los valores de $M$ atributos. Sean $n_i, i=1, \ldots M$ el número de valores del atributo $A_i$. Consideremos que en \D puede haber algún par atributo=valor que no aparezca por lo que su \soporte sería 0 y no aportaría información al análisis, imaginemos que son $N''$ los que no aparecen en \D. Todos los atributos tienen un valor "`más frecuente"' (y si no lo tienen se asigna ese apelativo al primero de los "`más frecuentes"'), del que vamos a prescindir porque la información que proporcionan la podemos obtener analizando el resto de valores del atributo, esto nos proporciona $M$ pares atributo=valor que no tendremos que considerar en el análisis. Luego nos quedan
\[N' = N - N'' - M\]
ítems que sí aportan información sobre \D. Los codificaremos usando los valores $0\ldots N'-1$ con lo que \aprioriL[1]$_{compacto}$ tendrá $N'$ elementos, cada uno de ellos guardará un \soporte y un vector con los ítems "`menores"' con que pueda estar relacionado, i.e., con los ítems representados por un número mayor pero que no sean valores del mismo atributo.


\afterpage{\clearpage}
\lstset{language=C++}
\lstinputlisting[label=clase:apriori:L:nodo,
                 caption={Librería \aprioriL\_compacto},
                 float=htb,
                 basicstyle=\scriptsize]
                 {./contenido/clasificacion/codigo/L_compacto.h}
\lstset{language=pseudocodigo}
